# -*- coding: utf-8 -*-
"""Gestionnaire (Publication de courses)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14_z-1AzUULDYdCEjMiOn7nYdz44ES57H
"""

# -*- coding: utf-8 -*-
import time, uuid, orjson, os, math, random, redis

# --- CONFIG ---
REDIS_HOST = os.getenv("REDIS_HOST", "127.0.0.1")
REDIS_PORT = int(os.getenv("REDIS_PORT", "6379"))

# --- CONNEXION REDIS ---
# decode_responses=True est important pour que les cl√©s/valeurs lues depuis les Hashes soient des strings
r = redis.Redis(host=REDIS_HOST, port=REDIS_PORT, decode_responses=True)

def haversine_km(lat1, lon1, lat2, lon2):
    """Calcule la distance entre deux points GPS."""
    R = 6371.0088
    phi1, phi2 = math.radians(lat1), math.radians(lat2)
    dphi = phi2 - phi1
    dlambda = math.radians(lon2 - lon1)
    a = math.sin(dphi/2)**2 + math.cos(phi1)*math.cos(phi2)*math.sin(dlambda/2)**2
    return R * (2 * math.atan2(math.sqrt(a), math.sqrt(1 - a)))

def publier_course(pickup, dropoff, fee):
    """Cr√©e une nouvelle course, la stocke dans Redis et la publie."""
    job_id = str(uuid.uuid4())
    distance_km = round(haversine_km(pickup["lat"], pickup["lng"], dropoff["lat"], dropoff["lng"]), 2)

    # MODIFICATION: Cr√©ation d'un HASH Redis pour stocker durablement la course
    job_details = {
        "job_id": job_id,
        "pickup_lat": pickup["lat"],
        "pickup_lng": pickup["lng"],
        "dropoff_lat": dropoff["lat"],
        "dropoff_lng": dropoff["lng"],
        "fee": float(fee),
        "distance_km": distance_km,
        "status": "published", # Le statut initial de la course
        "created_at": time.time(),
        "courier_id": "", # Sera rempli lors de l'assignation
        "picked_up_at": "",
        "delivered_at": ""
    }

    # Stockage de la course dans un hash avec la cl√© "job:{id}"
    r.hset(f"job:{job_id}", mapping=job_details)

    # Publication de l'√©v√©nement de nouvelle course (pour les livreurs et le s√©lecteur)
    # On publie seulement l'ID, les d√©tails sont dans le HASH
    message_pour_publication = {
        "job_id": job_id,
        "pickup": pickup,
        "dropoff": dropoff,
        "fee": job_details["fee"]
    }
    r.publish("jobs", orjson.dumps(message_pour_publication))

    print("üßë‚Äçüç≥ [Manager] Nouvelle course publi√©e et stock√©e :")
    print(f"  ‚Ä¢ ID : {job_id}")
    print(f"  ‚Ä¢ Statut initial : 'published'")
    print(f"  ‚Ä¢ R√©tribution : {job_details['fee']} ‚Ç¨")

    return job_id

def get_random_merchant():
    """R√©cup√®re un commer√ßant au hasard depuis Redis."""
    keys = r.keys("merchant:*")
    if not keys:
        print("‚ö†Ô∏è Aucun restaurant trouv√© dans Redis. Lancez d'abord import.py.")
        return None
    key = random.choice(keys)
    return r.hgetall(key)

if __name__ == "__main__":
    print("üöÄ Publication automatique de courses toutes les 30-40 secondes (Ctrl+C pour arr√™ter)")
    try:
        while True:
            merchant = get_random_merchant()
            if not merchant:
                time.sleep(35)
                continue

            try:
                # Gestion des diff√©rentes notations de latitude/longitude
                lat = float(merchant.get("latitude", merchant.get("Latitude", "0")))
                lng = float(merchant.get("longitude", merchant.get("Longitude", "0")))
            except (ValueError, TypeError):
                print(f"‚ö†Ô∏è Coordonn√©es invalides pour le commer√ßant {merchant.get('loc_name')}. On passe au suivant.")
                continue

            pickup = {"lat": lat, "lng": lng}
            dropoff = {
                "lat": lat + random.uniform(0.001, 0.02),
                "lng": lng + random.uniform(0.001, 0.02)
            }
            fee = round(random.uniform(5.0, 12.0), 2)
            publier_course(pickup, dropoff, fee)

            time.sleep(random.uniform(35, 40))

    except KeyboardInterrupt:
        print("\nüõë Arr√™t manuel du publisher.")
