# -*- coding: utf-8 -*-
"""Livreur (R√©ception et confirmation)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_R7AAcmHWkmId0h_ul9VXUcI73iQubAH
"""

# -*- coding: utf-8 -*-
import time, orjson, redis, random, sys, os

# --- CONFIG ---
REDIS_HOST = os.getenv("REDIS_HOST", "127.0.0.1")
REDIS_PORT = int(os.getenv("REDIS_PORT", "6379"))

# --- INITIALISATION ---
courier_id = sys.argv[1] if len(sys.argv) > 1 else f"c{random.randint(100,999)}"

# On utilise decode_responses=False pour orjson, mais on d√©code manuellement pour les cl√©s
r = redis.Redis(host=REDIS_HOST, port=REDIS_PORT, decode_responses=False)
ps = r.pubsub()

ps.subscribe("jobs")
ps.psubscribe(f"assignment:{courier_id}") # On √©coute seulement les assignations qui nous concernent

print(f"üö¥ [{courier_id}] En √©coute des nouvelles courses... (Ctrl+C pour quitter)")

def repondre_interet(job):
    """Envoie un message d'int√©r√™t pour une course sur le canal d√©di√©."""
    job_id = job["job_id"]
    payload = {
        "job_id": job_id,
        "courier_id": courier_id,
        "eta": random.randint(4, 12),
        "sent_at": time.time()
    }
    # Publie l'int√©r√™t pour que le manager le re√ßoive
    r.publish(f"interest:{job_id}", orjson.dumps(payload))
    print(f"üì® [{courier_id}] Int√©r√™t envoy√© pour la course {job_id}.")

def confirmer_recuperation(job_id):
    """Confirme au manager que la commande a √©t√© r√©cup√©r√©e."""
    payload = {"job_id": job_id, "courier_id": courier_id, "status": "picked_up", "timestamp": time.time()}
    r.publish("pickup_confirmations", orjson.dumps(payload))
    print(f"üõçÔ∏è  [{courier_id}] Commande {job_id} r√©cup√©r√©e. En route pour la livraison.")

def confirmer_livraison(job_id):
    """Confirme au manager que la commande a √©t√© livr√©e."""
    payload = {"job_id": job_id, "courier_id": courier_id, "status": "delivered", "timestamp": time.time()}
    r.publish("delivery_confirmations", orjson.dumps(payload))
    print(f"üèÅ [{courier_id}] Commande {job_id} livr√©e avec succ√®s !")

def a_deja_un_livreur(job_id: str) -> bool:
    """V√©rifie si la course a d√©j√† un livreur assign√© dans son HASH."""
    # On doit d√©coder la cl√© pour la comparaison
    courier_assigned = r.hget(f"job:{job_id}", "courier_id")
    return courier_assigned is not None and courier_assigned.decode('utf-8') != ""

def boucle_principale():
    """√âcoute les messages et g√®re le cycle de vie de la course pour le livreur."""
    current_job_id = None

    try:
        while True:
            # √âcoute des messages sur les canaux souscrits
            msg = ps.get_message(ignore_subscribe_messages=True, timeout=0.1)

            if not msg:
                time.sleep(0.05)
                continue

            channel = msg['channel'].decode('utf-8')
            data = orjson.loads(msg['data'])

            # --- CAS 1: Nouvelle course publi√©e sur le canal 'jobs' ---
            if channel == "jobs":
                job_id = data["job_id"]
                # Si le livreur est d√©j√† sur une course, il ignore les nouvelles
                if current_job_id:
                    continue

                print("\nüçΩÔ∏è  Nouvelle course disponible")
                print(f"  ‚Ä¢ ID : {job_id}")
                print(f"  ‚Ä¢ R√©tribution : {data['fee']} ‚Ç¨")

                if a_deja_un_livreur(job_id):
                    print("‚õî Course d√©j√† attribu√©e.")
                else:
                    choix = input("Accepter cette course ? (o/n) : ").strip().lower()
                    if choix == "o":
                        repondre_interet(data)
                    else:
                        print(f"‚ÑπÔ∏è [{courier_id}] Course ignor√©e.")

            # --- CAS 2: Assignation re√ßue sur le canal personnel ---
            elif channel == f"assignment:{courier_id}":
                job_id = data["job_id"]
                if data.get("courier_id") == courier_id:
                    print(f"\n‚úÖ [{courier_id}] Vous avez √©t√© s√©lectionn√© pour {job_id} !")
                    current_job_id = job_id

                    # Logique de confirmation
                    time.sleep(random.uniform(3, 6)) # Simule le temps pour aller au restaurant
                    input("Appuyez sur Entr√©e pour confirmer la r√©cup√©ration de la commande...")
                    confirmer_recuperation(current_job_id)

                    time.sleep(random.uniform(5, 10)) # Simule le temps de livraison
                    input("Appuyez sur Entr√©e pour confirmer la livraison chez le client...")
                    confirmer_livraison(current_job_id)

                    # La course est termin√©e, le livreur est de nouveau disponible
                    print(f"\nüéâ [{courier_id}] Mission accomplie. En attente de nouvelles courses.")
                    current_job_id = None

    except KeyboardInterrupt:
        print(f"\nüõë [{courier_id}] Arr√™t du livreur.")
    finally:
        ps.close()

if __name__ == "__main__":
    boucle_principale()