# -*- coding: utf-8 -*-
"""Gestionnaire (Sélection et suivi)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-9oUy8XQXkQ-IuYhVoWLFX-emc1D5pch
"""

# -*- coding: utf-8 -*-
import time, orjson, redis, os

# --- CONFIG ---
REDIS_HOST = os.getenv("REDIS_HOST", "127.0.0.1")
REDIS_PORT = int(os.getenv("REDIS_PORT", "6379"))

# --- CONNEXION REDIS ---
# On utilise decode_responses=False pour orjson, mais on décode manuellement pour les clés
r = redis.Redis(host=REDIS_HOST, port=REDIS_PORT, decode_responses=False)

def a_deja_un_livreur(job_id: str) -> bool:
    """Vérifie si la course a déjà un livreur assigné dans son HASH."""
    courier_assigned = r.hget(f"job:{job_id}", "courier_id")
    # La valeur sera en bytes, on vérifie si elle est non-vide
    return courier_assigned is not None and courier_assigned != b""

def assigner_course(job_id: str, courier_id: str) -> bool:
    """Met à jour le HASH de la course avec l'ID du livreur et le nouveau statut."""
    timestamp = time.time()
    # Utilisation de HSETNX pour garantir l'atomicité: on ne met le courier_id que s'il n'existe pas.
    # Si le champ est déjà rempli (même par une string vide), HSETNX ne fait rien.
    # Pour contourner, on met le courier_id, puis on met le statut.
    # Une transaction (pipeline) serait plus robuste mais c'est suffisant pour la simulation.
    if a_deja_un_livreur(job_id):
        return False

    r.hset(f"job:{job_id}", "courier_id", courier_id)
    r.hset(f"job:{job_id}", "status", "assigned")
    r.hset(f"job:{job_id}", "assigned_at", timestamp)

    # Notifier le livreur GAGNANT sur un canal qui lui est propre
    assign_msg = {"job_id": job_id, "courier_id": courier_id, "assigned_at": timestamp}
    r.publish(f"assignment:{courier_id}", orjson.dumps(assign_msg))

    print(f"✅ Course {job_id} attribuée à {courier_id}.")
    return True

def selectionner_livreur(job_id, fenetre_interets_sec=10):
    """Écoute les intérêts, sélectionne le meilleur, et assigne la course."""
    if a_deja_un_livreur(job_id):
        print(f"ℹ️ Course {job_id} déjà en cours d'assignation ou assignée.")
        return

    ps_interest = r.pubsub()
    canal = f"interest:{job_id}"
    ps_interest.subscribe(canal)
    print(f"⏳ [Manager] Écoute des intérêts pour {job_id} pendant {fenetre_interets_sec}s...")

    candidats = []
    selection = None
    fin = time.time() + fenetre_interets_sec

    while time.time() < fin:
        msg = ps_interest.get_message(ignore_subscribe_messages=True, timeout=1)
        if not msg:
            continue
        try:
            interet = orjson.loads(msg["data"])
            print(f"  -> Intérêt reçu de {interet['courier_id']} (ETA: {interet['eta']} mins)")
            candidats.append(interet)
        except Exception as e:
            print(f"  -> Intérêt mal formé reçu: {e}")

    ps_interest.close()

    if not candidats:
        print(f"❌ Aucun livreur intéressé pour {job_id}.")
        r.hset(f"job:{job_id}", "status", "unassigned") # Mettre à jour le statut
        return

    # Sélection du meilleur candidat (le plus rapide)
    candidats.sort(key=lambda x: x.get("eta", 999))
    selection = candidats[0]
    courier_id = selection["courier_id"]

    # Tentative d'assignation
    if not assigner_course(job_id, courier_id):
        courier_deja_assigne = r.hget(f'job:{job_id}', 'courier_id')
        if courier_deja_assigne:
            print(f"ℹ️ Course {job_id} a été attribuée à {courier_deja_assigne.decode('utf-8')} pendant la sélection.")

def boucle_principale():
    """Boucle principale qui écoute tous les canaux pertinents."""
    ps = r.pubsub()
    ps.subscribe(["jobs", "pickup_confirmations", "delivery_confirmations"])
    print("🔁 [Manager] En écoute des 'jobs' et des confirmations... (Ctrl+C pour quitter)")

    try:
        while True:
            msg = ps.get_message(ignore_subscribe_messages=True, timeout=1.0)
            if not msg:
                time.sleep(0.1)
                continue

            channel = msg['channel'].decode('utf-8')
            data = orjson.loads(msg['data'])
            job_id = data.get("job_id")

            if not job_id:
                continue

            # --- NOUVELLE COURSE PUBLIÉE ---
            if channel == "jobs":
                print(f"\n🆕 Nouvelle course détectée : {job_id}")
                selectionner_livreur(job_id, fenetre_interets_sec=7)

            # --- CONFIRMATION DE RÉCUPÉRATION ---
            elif channel == "pickup_confirmations":
                r.hset(f"job:{job_id}", "status", "picked_up")
                r.hset(f"job:{job_id}", "picked_up_at", data.get("timestamp"))
                print(f"🛍️  [SUIVI] Livreur {data['courier_id']} a récupéré la commande {job_id}.")

            # --- CONFIRMATION DE LIVRAISON ---
            elif channel == "delivery_confirmations":
                r.hset(f"job:{job_id}", "status", "delivered")
                r.hset(f"job:{job_id}", "delivered_at", data.get("timestamp"))
                print(f"🏁 [SUIVI] Livreur {data['courier_id']} a livré la commande {job_id}.")

    except KeyboardInterrupt:
        print("\n🛑 Arrêt manuel du manager.")
    finally:
        ps.close()

if __name__ == "__main__":
    boucle_principale()