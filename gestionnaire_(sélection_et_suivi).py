# -*- coding: utf-8 -*-
"""Gestionnaire (SÃ©lection et suivi)

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-9oUy8XQXkQ-IuYhVoWLFX-emc1D5pch
"""

# -*- coding: utf-8 -*-
import time, orjson, redis, os

# --- CONFIG ---
REDIS_HOST = os.getenv("REDIS_HOST", "127.0.0.1")
REDIS_PORT = int(os.getenv("REDIS_PORT", "6379"))

# --- CONNEXION REDIS ---
# On utilise decode_responses=False pour orjson, mais on dÃ©code manuellement pour les clÃ©s
r = redis.Redis(host=REDIS_HOST, port=REDIS_PORT, decode_responses=False)

def a_deja_un_livreur(job_id: str) -> bool:
    """VÃ©rifie si la course a dÃ©jÃ  un livreur assignÃ© dans son HASH."""
    courier_assigned = r.hget(f"job:{job_id}", "courier_id")
    # La valeur sera en bytes, on vÃ©rifie si elle est non-vide
    return courier_assigned is not None and courier_assigned != b""

def assigner_course(job_id: str, courier_id: str) -> bool:
    """Met Ã  jour le HASH de la course avec l'ID du livreur et le nouveau statut."""
    timestamp = time.time()
    # Utilisation de HSETNX pour garantir l'atomicitÃ©: on ne met le courier_id que s'il n'existe pas.
    # Si le champ est dÃ©jÃ  rempli (mÃªme par une string vide), HSETNX ne fait rien.
    # Pour contourner, on met le courier_id, puis on met le statut.
    # Une transaction (pipeline) serait plus robuste mais c'est suffisant pour la simulation.
    if a_deja_un_livreur(job_id):
        return False

    r.hset(f"job:{job_id}", "courier_id", courier_id)
    r.hset(f"job:{job_id}", "status", "assigned")
    r.hset(f"job:{job_id}", "assigned_at", timestamp)

    # Notifier le livreur GAGNANT sur un canal qui lui est propre
    assign_msg = {"job_id": job_id, "courier_id": courier_id, "assigned_at": timestamp}
    r.publish(f"assignment:{courier_id}", orjson.dumps(assign_msg))

    print(f"âœ… Course {job_id} attribuÃ©e Ã  {courier_id}.")
    return True

def selectionner_livreur(job_id, fenetre_interets_sec=10):
    """Ã‰coute les intÃ©rÃªts, sÃ©lectionne le meilleur, et assigne la course."""
    if a_deja_un_livreur(job_id):
        print(f"â„¹ï¸ Course {job_id} dÃ©jÃ  en cours d'assignation ou assignÃ©e.")
        return

    ps_interest = r.pubsub()
    canal = f"interest:{job_id}"
    ps_interest.subscribe(canal)
    print(f"â³ [Manager] Ã‰coute des intÃ©rÃªts pour {job_id} pendant {fenetre_interets_sec}s...")

    candidats = []
    selection = None
    fin = time.time() + fenetre_interets_sec

    while time.time() < fin:
        msg = ps_interest.get_message(ignore_subscribe_messages=True, timeout=1)
        if not msg:
            continue
        try:
            interet = orjson.loads(msg["data"])
            print(f"  -> IntÃ©rÃªt reÃ§u de {interet['courier_id']} (ETA: {interet['eta']} mins)")
            candidats.append(interet)
        except Exception as e:
            print(f"  -> IntÃ©rÃªt mal formÃ© reÃ§u: {e}")

    ps_interest.close()

    if not candidats:
        print(f"âŒ Aucun livreur intÃ©ressÃ© pour {job_id}.")
        r.hset(f"job:{job_id}", "status", "unassigned") # Mettre Ã  jour le statut
        return

    # SÃ©lection du meilleur candidat (le plus rapide)
    candidats.sort(key=lambda x: x.get("eta", 999))
    selection = candidats[0]
    courier_id = selection["courier_id"]

    # Tentative d'assignation
    if not assigner_course(job_id, courier_id):
        courier_deja_assigne = r.hget(f'job:{job_id}', 'courier_id')
        if courier_deja_assigne:
            print(f"â„¹ï¸ Course {job_id} a Ã©tÃ© attribuÃ©e Ã  {courier_deja_assigne.decode('utf-8')} pendant la sÃ©lection.")

def boucle_principale():
    """Boucle principale qui Ã©coute tous les canaux pertinents."""
    ps = r.pubsub()
    ps.subscribe(["jobs", "pickup_confirmations", "delivery_confirmations"])
    print("ğŸ” [Manager] En Ã©coute des 'jobs' et des confirmations... (Ctrl+C pour quitter)")

    try:
        while True:
            msg = ps.get_message(ignore_subscribe_messages=True, timeout=1.0)
            if not msg:
                time.sleep(0.1)
                continue

            channel = msg['channel'].decode('utf-8')
            data = orjson.loads(msg['data'])
            job_id = data.get("job_id")

            if not job_id:
                continue

            # --- NOUVELLE COURSE PUBLIÃ‰E ---
            if channel == "jobs":
                print(f"\nğŸ†• Nouvelle course dÃ©tectÃ©e : {job_id}")
                selectionner_livreur(job_id, fenetre_interets_sec=7)

            # --- CONFIRMATION DE RÃ‰CUPÃ‰RATION ---
            elif channel == "pickup_confirmations":
                r.hset(f"job:{job_id}", "status", "picked_up")
                r.hset(f"job:{job_id}", "picked_up_at", data.get("timestamp"))
                print(f"ğŸ›ï¸  [SUIVI] Livreur {data['courier_id']} a rÃ©cupÃ©rÃ© la commande {job_id}.")

            # --- CONFIRMATION DE LIVRAISON ---
            elif channel == "delivery_confirmations":
                r.hset(f"job:{job_id}", "status", "delivered")
                r.hset(f"job:{job_id}", "delivered_at", data.get("timestamp"))
                print(f"ğŸ [SUIVI] Livreur {data['courier_id']} a livrÃ© la commande {job_id}.")

    except KeyboardInterrupt:
        print("\nğŸ›‘ ArrÃªt manuel du manager.")
    finally:
        ps.close()

if __name__ == "__main__":
    boucle_principale()